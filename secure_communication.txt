#
# How to securely communicate a message (e.g. email address) across a
# publicly visible channel (e.g. the GitHub issue tracker) with an ssh
# public key from a 2048 bit (ssh-keygen default) RSA key pair.
#
# The method is limited to 244 character messages, more or less, depending
# on the actual size of the public key that 'ssh-keygen' creates.  If you
# use a 4096 bit key, the limit is 500 characters, more or less.
#
# In what follows, '#' precedes explanatory comments, '~$' is the shell
# prompt and precedes commands, and '>' is the shell continuation prompt,
# induced by '\' at the end of the previous line.
#
### Either receiver or sender does this:
#
# The public keys of a GitHub user may be found at:
#   https://github.com/user_name.keys
# where 'user_name' is the user in which you have an interest.  If the
# keys are elliptic curve keys, you are on your own.  The method here
# might work or it might not - I have not tried it.
#
# 1) Convert the receiver's ssh public key file to a pem file:
# (Wikipedia says 'PEM is a defacto file format for storing and sending
#  cryptography keys, certificates, and other data, based on a set of
#  1993 IETF standards defining "privacy-enhanced mail." '.  The email
#  system itself, for which it was defined is now defunct.  A pem file
#  is plain text.)
#
~$ ssh-keygen -f id_rsa.pub -e -m PKCS8 > id_rsa.pub.pem
#
# This uses the command 'ssh-keygen' with the input file (-f) 'id_rsa.pub'
# and exports it (-e) in format (mode: -m) 'PKCS8' (Public Key Cryptography
# Standards format 8) into the file 'id_rsa.pub.pem', destroying any already
# existing file with that name in the current working directory.
#
# NOTA BENE: the pem file is the same whether '-f' specifies 'id_rsa' or
#            'id_rsa.pub': identical public key pem files are generated
#            in both cases.  Only the receiver has access to 'id_rsa'.
#            This command is therefore SAFE for the uninformed.
#
# Alternatively, you may use 'openssl' with the sub-command 'rsa' to
# generate the pem file.  This process clarifies the generality of the
# pem file format and the asymmetric nature of public and private keys:
#
~$ openssl rsa -in id_rsa -outform pem -pubout > id_rsa.pub.pem
~$ openssl rsa -in id_rsa -outform pem         > id_rsa.prv.pem
#
# NOTA BENE: 'id_rsa.prv.pem' is identical to 'id_rsa' (if there is no
#            pass-phrase encrypting it), and represents the ssh private
#            key.  It should NOT be publicly accessible.  Even encrypted,
#            it should not be publicly available.  This command is therefore
#            UNSAFE for the uninformed.  A pem file is clearly marked with a
#            header describing its content.  It is advisable to open the
#            file to be sure it is a public key before posting.
#
### Sender does this:
#
# 2) Create the cipher text:
#   a) use command 'echo' to pipe (|) your short message text into the
#      command 'openssl'.
#   b) use the openssl subcommand 'rsautl' (RSA utility) to encrypt the
#      short message, specifying a public key, using the pem file generated
#      in step 1).
#   c) pipe the binary cipher text to the command 'base64' to convert it to
#      a printable text representation.
#
~$ echo "secret message" | \
> openssl rsautl -encrypt -pubin -inkey id_rsa.pub.pem | \
> base64
#
# example output using a 2048 bit key:
#
KTmuMNlWxyMA9jIKSbGbEiFOQTEExHxQmFL6+782PkZgRAAEuXiUozBqS215oYfVC3WIAHrWRUFL
OK6AfD5YT8xElQVzDOiWswvavquFimA/yeuKX1+5dEri7QakM6E1OvFlrZ4aKZ+i9Wspw0T8xOYg
f56MopJRmltrdtSn2ygmq+EnfR6nmAQJEx5vAx4+t9feybOGu2HdmTinoI/rXVez8IFuLOfPzO/+
mC9Wv3xfviwnBuDdE5ZZNyZGrHKHGFpvNo4K0idVn1P4EZFKKLma+xsNHRkhggdj32zGCkVL40F4
akGzv3yohYG6z/4waY+Fj46fv0HiKbnbSF0SsQ==
#
# 3) Copy/paste the output into an email or messaging application and send.
#
### Receiver does this:
#
# 4) Decrypt the cipher text
#   a) copy/paste the cipher text as the 'echo' command argument
#   b) pipe the output into the command 'base64 -d' to regenerate the
#      binary data stream.
#   c) pipe that into 'openssl', this time using the '-decrypt' option
#      and the ssh private key file associated with the public key that
#      was used to generate the pem file in step 1).
#
~$ echo "KTmuMNlWxyMA9jIKSbGbEiFOQTEExHxQmFL6+782PkZgRAAEuXiUozBqS215oYfVC3WIAHrWRUFL
OK6AfD5YT8xElQVzDOiWswvavquFimA/yeuKX1+5dEri7QakM6E1OvFlrZ4aKZ+i9Wspw0T8xOYg
f56MopJRmltrdtSn2ygmq+EnfR6nmAQJEx5vAx4+t9feybOGu2HdmTinoI/rXVez8IFuLOfPzO/+
mC9Wv3xfviwnBuDdE5ZZNyZGrHKHGFpvNo4K0idVn1P4EZFKKLma+xsNHRkhggdj32zGCkVL40F4
akGzv3yohYG6z/4waY+Fj46fv0HiKbnbSF0SsQ==" | \
> base64 -d | \
> openssl rsautl -decrypt -inkey id_rsa
#
# example output:
#
secret message
#
# NOTA BENE: The ssh file 'id_rsa' is already a pem file - it is identical
#            to 'id_rsa.prv.pem' generated by the 'openssl rsa' command
#            used in step 1) above (if there is no pass-phrase encrypting it).
#
# That's all!
#
### References:
#
# If you wish to communicate large files using this method, you can find a
# useful summary of the expanded process here:
#
#   http://www.czeskis.com/random/openssl-encrypt-file.html
#
# While I can not recommend most of this next fellow's web-log, much of
# it being polluted with political commentary, this entry is not only
# pure, but very informative, covering many implementation details:
#
#   https://www.netmeister.org/blog/ssh2pkcs8.html
#
# Jan Schauma is clearly very knowledgable and talented.
#
